### 答疑（五）：网络收发过程中，缓冲区位置在哪里？

1. 概念

> 这些缓冲区都处于内核管理的内存中。
>
> - 其中，环形缓冲区，由于需要 DMA 与网卡交互，理应属于网卡设备驱动的范围。
> - sk_buff 缓冲区，是一个维护网络帧结构的双向链表，链表中的每一个元素都是一个网络帧（Packet）。虽然 TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而无需进行数据复制。
> - 套接字缓冲区，则允许应用程序，给每个套接字配置不同大小的接收或发送缓冲区。应用程序发送数据，实际上就是将数据写入缓冲区；而接收数据，其实就是从缓冲区中读取。至于缓冲区中数据的进一步处理，则由传输层的 TCP 或 UDP 协议来完成。

> Linux 协议栈，通过五元组来标志一个连接（即协议，源 IP、源端口、目的 IP、目的端口)。明白了这一点，这个问题其实就有了思路。我们应该分客户端和服务器端，这两种场景来分析。
>
> - 对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 65535 个连接。
> - 对服务器端来说，其通常监听在固定端口上（比如 80 端口），等待客户端的连接。根据五元组结构，我们知道，客户端的 IP 和端口都是可变的。如果不考虑 IP 地址分类以及资源限制，服务器端的理论最大连接数，可以达到 2 的 48 次方（IP 为 32 位，端口号为 16 位），远大于 65535。
>
> 所以，综合来看，客户端最大支持 65535 个连接，而服务器端可支持的连接数是海量的。

2. 涉及到的命令

```shell

```

3. 结论

> 

### 案例篇：为什么应用容器化后，启动慢了很多？

1. 概念

> 

2. 涉及到的命令

```shell
$ for ((i=0;i<30;i++)); do curl localhost:8080; sleep 1; done

# 显示容器状态，jq用来格式化json输出
$ docker inspect tomcat -f '{{json .State}}' | jq

# 执行 dmesg 命令，查看系统日志，并定位 OOM 相关的日志
$ dmesg
```

3. 结论

> 虽然我们通过增大 CPU 的限制，解决了这个问题。不过再碰到类似问题，你可能会觉得这种方法太麻烦了。因为要设置容器的资源限制，还需要我们预先评估应用程序的性能。显然还有更简单的方法，比如说直接去掉限制，让容器跑就是了。
>
> 不过，这种简单方法，却很可能带来更严重的问题。没有资源限制，就意味着容器可以占用整个系统的资源。这样，一旦任何应用程序发生异常，都有可能拖垮整台机器。
>
> 实际上，这也是在各大容器平台上最常见的一个问题。一开始图省事不设限，但当容器数量增长上来的时候，就会经常出现各种异常问题。最终查下来，可能就是因为某个应用资源使用过高，导致整台机器短期内无法响应。只有设置了资源限制，才能确保杜绝类似问题。

### 案例篇：服务器总是时不时丢包，我该怎么办？

1. 概念

> 容器化后，应用程序会通过命名空间进行隔离。所以，你在分析时，不要忘了结合命名空间、cgroups、iptables 等来综合分析。比如：
>
> - cgroups 会影响容器应用的运行；
> - iptables 中的 NAT，会影响容器的网络性能；
> - 叠加文件系统，会影响应用的 I/O 性能等。

2. 涉及到的命令

```shell
# 这里我没有使用 ping，是因为 ping 基于 ICMP 协议，而 Nginx 使用的是 TCP 协议
# -c表示发送10个请求，-S表示使用TCP SYN，-p指定端口为80
$ hping3 -c 10 -S -p 80 192.168.0.30

# 查询 DROP 和 REJECT 等规则的统计信息
$ iptables -t filter -nvL
```

3. 结论

> 网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进一步还会导致网络延迟增大、吞吐降低。
>
> 碰到丢包问题时，我们还是要从 Linux 网络收发的流程入手，结合 TCP/IP 协议栈的原理来逐层分析。从链路层、网络层和传输层等入手，分析网络丢包的问题。

### 案例篇：内核线程 CPU 利用率太高，我该怎么办？

1. 概念

> Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。
>
> - 0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。
> - 1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。
> - 2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。
>
> 要理解火焰图，我们最重要的是区分清楚横轴和纵轴的含义。
>
> - 横轴表示采样数和采样比例。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。
> - 纵轴表示调用栈，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。

2. 涉及到的命令

```shell
# 执行下面的 perf record 命令；并指定进程号 9 ，以便记录 ksoftirqd 的行为
# 采样30s后退出
$ perf record -a -g -p 9 -- sleep 30
```

3. 结论

> 

### 案例篇：动态追踪怎么用？

1. 概念

> 动态追踪技术，通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。

![动态追踪](./img/动态追踪.png)

2. 涉及到的命令

```shell

```

3. 结论

> - 在不需要很高灵活性的场景中，使用 perf 对性能事件进行采样，然后再配合火焰图辅助分析，就是最常用的一种方法；
> - 而需要对事件或函数调用进行统计分析（比如观察不同大小的 I/O 分布）时，就要用 SystemTap 或者 eBPF，通过一些自定义的脚本来进行数据处理。
