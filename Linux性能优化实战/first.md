## 开篇词笔记
工作这么长时间，其实没有怎么涉及到服务器性能优化的问题，唯一的一次，还是在上上家公司的时候，有一天突然觉得服务器的api访问比较慢，leader就安排检查一下，依稀记得那次只会用个top命令，具体每个数据什么意思也不太清楚，也没有检查出来原因，后续也就不了了之了。

偶然看到Go夜读组织的这次读书会活动，一冲动就参加了，希望自己能够坚持下来，真正学到东西，在下次再出现Linux服务器性能问题的时候，知道如何去分析。

## CPU性能篇笔记
### 基础篇：到底应该怎么理解“平均负载”？

1. 概念

> 简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。这里我先解释下，可运行状态和不可中断状态这俩词儿。

> 什么是可运行状态？

> 什么是不可中断状态？

> 平均负载与 CPU 使用率没有对应关系，为什么？

2. 涉及到的命令

```shell
$ uptime

$ grep 'model name' /proc/cpuinfo | wc -l2

# -d 参数表示高亮显示变化的区域
$ watch -d uptime

# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5

# 间隔5秒后输出一组数据，-u表示CPU指标
$ pidstat -u 5 1
```

3. 结论

> 平均负载高有可能是 CPU 密集型进程导致的；
> 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
> 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。> 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。

### 基础篇：经常说的 CPU 上下文切换是什么意思？

1. 概念

> 进程在竞争 CPU 的时候并没有真正运行，为什么还会导致系统的负载升高呢？CPU 上下文切换就是罪魁祸首。

> 在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。

> CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

> 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。

> 所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

> 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

2. 涉及到的命令

```shell
# 每隔5秒输出1组数据
$ vmstat 5

# 每隔5秒输出1组数据
$ pidstat -w 5

# 每隔1秒输出一组数据（需要 Ctrl+C 才结束）
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -wt 1

# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
```

3. 结论

>CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。

> 但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。

> 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；

> 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；

> 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

### 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？
1. 概念

> 通常所说的 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比。

2. 涉及到的命令
```shell
# 只保留各个CPU的数据
$ cat /proc/stat | grep ^cpu

# 并发100个请求测试Nginx性能，总共测试1000个请求
$ ab -c 100 -n 1000 http://192.168.0.10:10000/

# 默认每3秒刷新一次
$ top

# 每隔1秒输出一组数据，共输出5组
$ pidstat 1 5

# -g开启调用关系分析，-p指定php-fpm的进程号21515
$ perf top -g -p 21515
```
3. 结论

> 碰到 CPU 使用率升高的问题，你可以借助 top、pidstat 等工具，确认引发 CPU 性能问题的来源；再使用 perf 等工具，排查出引起性能问题的具体函数。

### 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？
1. 概念

> 系统的 CPU 使用率，不仅包括进程用户态和内核态的运行，还包括中断处理、等待 I/O 以及内核线程等。所以，当你发现系统的 CPU 使用率很高的时候，不一定能找到相对应的高 CPU 使用率的进程。

2. 涉及到的命令
```shell
$ pstree | grep stress

# 记录性能事件，等待大约15秒后按 Ctrl+C 退出
$ perf record -g

# 查看报告
$ perf report

# execsnoop就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果 
# 按 Ctrl+C 结束
$ execsnoop
```
3. 结论

> 碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题，比如有可能是下面这两种情况。

> 第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。

> 第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。

### 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？
1. 概念
2. 涉及到的命令
3. 结论

> 不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。

> 僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。
